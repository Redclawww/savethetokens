#!/usr/bin/env python3
"""
Session Hook Generator - Creates optimized .claude/hooks/session-start.sh

Generates smart session-start hooks that:
- Check project status (database, services)
- Detect current work context
- Show relevant documentation links
- Provide environment-aware guidance
"""

import json
import re
import sys
from pathlib import Path
from typing import Optional


class SessionHookGenerator:
    """Generates optimized Claude Code session-start hooks."""
    
    # Detectable project types and their checks
    PROJECT_PATTERNS = {
        "nodejs": {
            "indicators": ["package.json", "node_modules"],
            "checks": [
                ("Database", "docker ps | grep -q postgres", "PostgreSQL"),
                ("Cache", "docker ps | grep -q redis", "Redis"),
                ("Services", "docker-compose ps 2>/dev/null | grep -q Up", "Docker services")
            ],
            "dev_command": "npm run dev",
            "test_command": "npm test"
        },
        "python": {
            "indicators": ["requirements.txt", "pyproject.toml", "setup.py"],
            "checks": [
                ("Database", "docker ps | grep -q postgres", "PostgreSQL"),
                ("Cache", "docker ps | grep -q redis", "Redis"),
                ("Venv", "[ -d '.venv' ] || [ -d 'venv' ]", "Virtual environment")
            ],
            "dev_command": "python manage.py runserver",
            "test_command": "pytest"
        },
        "rust": {
            "indicators": ["Cargo.toml"],
            "checks": [
                ("Build", "[ -d 'target' ]", "Built artifacts"),
            ],
            "dev_command": "cargo run",
            "test_command": "cargo test"
        },
        "go": {
            "indicators": ["go.mod"],
            "checks": [
                ("Database", "docker ps | grep -q postgres", "PostgreSQL"),
            ],
            "dev_command": "go run .",
            "test_command": "go test ./..."
        }
    }
    
    # Context detection patterns
    CONTEXT_PATTERNS = {
        "testing": {
            "files": ["test/", "tests/", "spec/", "__tests__/", "*_test.py", "*_test.go", "*.test.ts"],
            "doc": "docs/TESTING.md",
            "icon": "üß™",
            "message": "Testing context detected"
        },
        "api": {
            "files": ["api/", "routes/", "controllers/", "endpoints/"],
            "doc": "docs/API.md",
            "icon": "üîå",
            "message": "API development context detected"
        },
        "database": {
            "files": ["prisma/", "migrations/", "schema/", "models/", "alembic/"],
            "doc": "docs/DATABASE.md",
            "icon": "üóÑÔ∏è",
            "message": "Database work detected",
            "warning": "‚ö†Ô∏è  Don't forget to review migrations carefully!"
        },
        "deployment": {
            "files": ["Dockerfile", "docker-compose", "k8s/", ".github/workflows/", ".gitlab-ci"],
            "doc": "docs/DEPLOYMENT.md",
            "icon": "üöÄ",
            "message": "Deployment context detected"
        },
        "frontend": {
            "files": ["components/", "pages/", "views/", "public/", "static/"],
            "doc": "docs/FRONTEND.md",
            "icon": "üé®",
            "message": "Frontend work detected"
        }
    }
    
    def __init__(self, project_root: str | Path):
        self.project_root = Path(project_root)
        self.project_type = self._detect_project_type()
    
    def _detect_project_type(self) -> Optional[str]:
        """Detect project type from indicators."""
        for proj_type, config in self.PROJECT_PATTERNS.items():
            for indicator in config["indicators"]:
                if (self.project_root / indicator).exists():
                    return proj_type
        return None
    
    def generate_hook(
        self,
        include_git: bool = True,
        include_context_detection: bool = True,
        include_environment: bool = True,
        include_timing: bool = False
    ) -> str:
        """
        Generate session-start hook script.
        
        Args:
            include_git: Include git branch/commit info
            include_context_detection: Detect work context from recent changes
            include_environment: Show environment-specific guidance
            include_timing: Measure hook execution time
            
        Returns:
            Bash script content
        """
        lines = [
            "#!/bin/bash",
            "# Generated by Context Governor - Session Hook Generator",
            "# Optimized for fast startup and relevant context",
            "",
            "set -euo pipefail",
            ""
        ]
        
        # Add timing if requested
        if include_timing:
            lines.extend([
                "# Measure execution time",
                "START_TIME=$(date +%s%N)",
                ""
            ])
        
        # Header
        project_name = self.project_root.name
        lines.extend([
            f'echo "üöÄ {project_name} Status"',
            'echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"',
            ""
        ])
        
        # Add project-specific checks
        if self.project_type:
            config = self.PROJECT_PATTERNS[self.project_type]
            lines.append("# Service Status")
            
            for name, check_cmd, description in config["checks"]:
                lines.extend([
                    f"if {check_cmd}; then",
                    f'    echo "‚úÖ {description}: Running"',
                    "else",
                    f'    echo "‚ùå {description}: Not running"',
                    "fi"
                ])
            
            lines.append("")
        
        # Git context
        if include_git:
            lines.extend([
                "# Git Context",
                'if git rev-parse --git-dir > /dev/null 2>&1; then',
                '    BRANCH=$(git branch --show-current 2>/dev/null || echo "detached")',
                '    LAST_COMMIT=$(git log -1 --oneline 2>/dev/null || echo "No commits")',
                '    echo ""',
                '    echo "üìç Branch: $BRANCH"',
                '    echo "   Last: $LAST_COMMIT"',
                'fi',
                ""
            ])
        
        # Context detection
        if include_context_detection:
            lines.extend([
                "# Detect Work Context",
                "detect_context() {",
                '    local changed=$(git diff --name-only HEAD~1 2>/dev/null || echo "")',
                '    [ -z "$changed" ] && return',
                '    echo ""',
                ""
            ])
            
            for context_name, context_config in self.CONTEXT_PATTERNS.items():
                patterns = context_config["files"]
                grep_patterns = []
                for pattern in patterns:
                    escaped = re.escape(pattern)
                    escaped = escaped.replace(r"\*", ".*")
                    grep_patterns.append(escaped)
                pattern_grep = "|".join(grep_patterns)
                
                lines.extend([
                    f'    if echo "$changed" | grep -qE "{pattern_grep}"; then',
                    f'        echo "{context_config["icon"]} {context_config["message"]}"',
                    f'        echo "   üìö See: {context_config["doc"]}"',
                ])
                
                if "warning" in context_config:
                    lines.append(f'        echo "   {context_config["warning"]}"')
                
                lines.extend([
                    "        return",
                    "    fi",
                    ""
                ])
            
            lines.extend([
                "}",
                "detect_context",
                ""
            ])
        
        # Environment awareness
        if include_environment:
            lines.extend([
                "# Environment Detection",
                'if [ -f ".env.production" ] || [ -f "prod.env" ]; then',
                '    echo ""',
                '    echo "üî¥ PRODUCTION environment detected"',
                '    echo "   ‚ö†Ô∏è  Extra caution required!"',
                '    echo "   - All changes require PR review"',
                '    echo "   - Test in staging first"',
                '    echo "   - Never delete data without backup"',
                'elif [ -f ".env.staging" ] || [ -f "staging.env" ]; then',
                '    echo ""',
                '    echo "üü° STAGING environment"',
                '    echo "   - Safe to test changes"',
                '    echo "   - Mirrors production setup"',
                'else',
                '    echo ""',
                '    echo "üü¢ DEVELOPMENT environment"',
                '    echo "   - Local machine, safe to experiment"',
                'fi',
                ""
            ])
        
        # Footer
        lines.extend([
            'echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"',
            ""
        ])
        
        # Add timing measurement
        if include_timing:
            lines.extend([
                "# Show execution time",
                "END_TIME=$(date +%s%N)",
                'DURATION=$(( (END_TIME - START_TIME) / 1000000 ))',
                'echo "‚è±Ô∏è  Hook: ${DURATION}ms"',
                ""
            ])
        
        # Quick reference hint
        lines.extend([
            '# Quick Reference',
            'if [ -f "docs/QUICK_REF.md" ]; then',
            '    echo "üí° Quick commands: docs/QUICK_REF.md"',
            'fi',
            "",
            '# Token Hygiene',
            'echo ""',
            'echo "üß† Token hygiene:"',
            'echo "   - Use ! <command> for direct shell commands"',
            'echo "   - Keep one session per task"',
            'echo "   - Run /context and compact around 50%"',
            'if [ -f ".claude/checkpoints/latest.md" ]; then',
            '    echo "   - Latest checkpoint: .claude/checkpoints/latest.md"',
            'else',
            '    echo "   - Save checkpoint: python scripts/session_checkpoint.py --task <goal>"',
            'fi',
            ""
        ])
        
        return "\n".join(lines)
    
    def create_hook_file(self, output_dir: Optional[str | Path] = None) -> Path:
        """
        Create the session-start hook file.
        
        Args:
            output_dir: Directory for .claude/hooks/ (defaults to project root)
            
        Returns:
            Path to created hook file
        """
        if output_dir is None:
            output_dir = self.project_root
        
        hooks_dir = Path(output_dir) / ".claude" / "hooks"
        hooks_dir.mkdir(parents=True, exist_ok=True)
        
        hook_file = hooks_dir / "session-start.sh"
        content = self.generate_hook()
        
        hook_file.write_text(content)
        hook_file.chmod(0o755)  # Make executable
        
        return hook_file
    
    @classmethod
    def analyze_existing_hook(cls, hook_path: str | Path) -> dict:
        """
        Analyze existing session-start hook.
        
        Returns:
            Analysis with optimization suggestions
        """
        hook_path = Path(hook_path)
        
        if not hook_path.exists():
            return {
                "exists": False,
                "suggestions": ["Create a session-start hook to optimize context loading"]
            }
        
        content = hook_path.read_text()
        lines = content.split("\n")
        
        analysis = {
            "exists": True,
            "line_count": len(lines),
            "has_timing": "START_TIME" in content or "date +%s" in content,
            "has_git_info": "git branch" in content or "git log" in content,
            "has_docker_checks": "docker ps" in content or "docker-compose" in content,
            "has_context_detection": "git diff" in content and "detect" in content.lower(),
            "suggestions": []
        }
        
        # Generate suggestions
        if not analysis["has_timing"]:
            analysis["suggestions"].append("Add timing measurement to track hook performance")
        
        if not analysis["has_context_detection"]:
            analysis["suggestions"].append("Add smart context detection based on recent changes")
        
        if not analysis["has_git_info"]:
            analysis["suggestions"].append("Show current git branch and last commit")
        
        if len(lines) > 100:
            analysis["suggestions"].append(f"Hook is long ({len(lines)} lines) - consider simplifying")
        
        return analysis


def main():
    """CLI entry point."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Generate optimized Claude Code session-start hooks"
    )
    parser.add_argument(
        "--project", "-p",
        default=".",
        help="Project root directory (default: current)"
    )
    parser.add_argument(
        "--output", "-o",
        help="Output directory (default: project root)"
    )
    parser.add_argument(
        "--no-git",
        action="store_true",
        help="Don't include git information"
    )
    parser.add_argument(
        "--no-context",
        action="store_true",
        help="Don't include context detection"
    )
    parser.add_argument(
        "--no-env",
        action="store_true",
        help="Don't include environment detection"
    )
    parser.add_argument(
        "--timing",
        action="store_true",
        help="Include execution timing"
    )
    parser.add_argument(
        "--analyze",
        help="Analyze existing hook file"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print script without creating file"
    )
    
    args = parser.parse_args()
    
    # Analyze existing hook
    if args.analyze:
        analysis = SessionHookGenerator.analyze_existing_hook(args.analyze)
        print(json.dumps(analysis, indent=2))
        return 0
    
    # Generate new hook
    generator = SessionHookGenerator(args.project)
    
    if args.dry_run:
        script = generator.generate_hook(
            include_git=not args.no_git,
            include_context_detection=not args.no_context,
            include_environment=not args.no_env,
            include_timing=args.timing
        )
        print(script)
    else:
        hook_file = generator.create_hook_file(args.output)
        print(f"‚úÖ Created session-start hook: {hook_file}")
        print(f"   Made executable (chmod +x)")
        print(f"\nTest it:")
        print(f"   {hook_file}")
        
        # Show detected project type
        if generator.project_type:
            print(f"\nDetected project type: {generator.project_type}")
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
